## 2. Trailing Zeros

### Description

Write an algorithm which computes the number of trailing zeros in n factorial.



Example

**11! = 39916800**, so the out should be 2



### 题意

求n的阶乘结果中从最后一位数起有多少个连续的0



### 分析

#### 原理

假如你把1 × 2 ×３× 4 ×……×N中每一个因数分解质因数，结果就像： 
1 × 2 × 3 × (2 × 2) × 5 × (2 × 3) × 7 × (2 × 2 ×2) ×…… 
10进制数结尾的每一个0都表示有一个因数10存在——任何进制都一样，对于一个M进制的数，让结尾多一个0就等价于乘以M。 
10可以分解为2 × 5——因此只有质数2和5相乘能产生0，别的任何两个质数相乘都不能产生0，而且2，5相乘只产生一个0。 
所以，分解后的整个因数式中有多少对(2, 5)，结果中就有多少个0，而分解的结果中，2的个数显然是多于5的，因此，有多少个5，就有多少个(2, 5)对。 
所以，讨论1000的阶乘结尾有几个0的问题，就被转换成了1到1000所有这些数的质因数分解式有多少个5的问题。 

对n！中1~n进行因式分解



#### 举例

`11！= 1 * 2 * 3 * （2 * 2） * 5 * （2 * 3） * 7 * （2 * 2 * 2）* （3 * 3） * （2 * 5） * 11`

中有8个2，2个5，因此11！结果中有2个0



#### 算法

至于一个数阶乘的末尾有多少个0，0的个数为（其中的“/”是取整除法）： 
例子：1000的阶乘末尾0的个数 
1000/5 + 1000/25 + 1000/125 + 1000/625 
= 200 + 40 + 8 + 1 
= 249(个)



#### 算法解释

1000/5求得的是1000中5的倍数的个数，1000/25求得的是1000中25的倍数的个数，为什么对1000/5+1000/25+...+1000/625可以求得最终因式分解后的5的个数呢？

原因就是25的倍数一定是5的倍数，而1000/5已经统计过了一次可以整除5一次的数的个数，1000/25统计的时候，是统计可以整除5两次的数的个数，所以本质上是对那些可以分解出5的数进行逐次分解，{n%5==0, n∈[1,1000]} ⊇ {n%25==0, n∈[1,1000]} ...，按次数递增统计这些数的个数，最后得到因式分解后5的个数。



